# 	字符串方法

## 截取类方法

### slice

```javascript
var str = 'kaikeba';
var str2 = str.slice(begin,end) // kaikeba  
//-begin
	//截取的起始位置，不传默认为0.可以接受负数，如果是负数，则会倒数n位
//-end
	//截取的结束位置，默认是length，不包括end，负数也会倒数n位
```

### substr

```javascript
var str = "kaikeba";
str.substr(0)//kaikeba
str.substr(2)//ikeba
/*
substr(start[length])
截取从start位置开始的字符,返回的是新字符串并不会改变原有字符串
	参数
		start:截取的起始位置，负数同倒数， length +(start)，如果起始位置太大默认为0
		length:截取字符的个数,如果不填默认到结尾 如果个数为负数，返回空
*/
```

### 	substring

```javascript
var str = "kaikeba";
str.subString();//kaikeba
/*
	str.substring(begin,end)
		返回截取的字符串的
			begin:截取的起始位置，默认为0，如果小于0就会等于0，如果超过length，会返回一个空的字符串
			end:截取的结束位置，默认是length，如果超过length，默认为length，end小于0 默认为0
		如果起始的begin对应的值得索引在后，end的值索引在前，那么就会将begin和end调换
*/
```

## 其他常用方法

### split

```javascript
var str = "kai-ke-ba";
str.split()//字符串变成一个数组
/*
	split(separator[,num])
		-separator 决定分割的字符,该字符的位置会作为分割点，并且自己是并不在当前数组内的，
			如果是空字符串，可以把每一个字符都分割开来。
			如果分割的字符处在首尾，会有一个空字符串
		-num 可选，决定分割得数组中的个数
*/
```

### concat

```javascript
var str1 = "kai"
var str2 ="ke"
var str3 = "ba"
str1.concat(str2,str3);//kaikaiba
str1//kai
/*
	返回的是一个新的字符串，并不会改变原有的字符串
	+=的性能要比concat更好一些
*/
```

### toLowerCase()

```javascript
var str1 = "A"
var str2 = "a"
console.log(str1.toLowerCase() === str2); // true

/*
	toLowerCase() - 把字符串转成小写
	toUpperCase() - 把字符串转成大写
*/
```

### 去除首位空格

```javascript
var str = " kaikeba ";
str.trim()//去除空格
```

# 数组方法

## push

```javascript
var arr = [1,2,3];
arr.push(4,5,6,7);//返回的是当前被修改后的数组的最新长度，会改变原来的数组 
```

## pop

```javascript
var arr = [1,2,3];
arr.pop();//用于删除数组中的最后一个元素,返回的是被删除的元素
```

## unshift

```javascript
var arr = [1,2,3]
arr.unshift(4)//返回最新长度，会改变原来的数组，将元素添加到数组的开头
```

## shift

```javascript
var arr = [1,2,3]
arr.shift();//删除开头元素，返回的是被删除的元素
```

## splice

```javascript
var arr = [1,2,3];
//删除
arr.splice(1,2);//1
//替换
arr.splice(1,2,"b","c")//[1,"b","c"]
//添加
arr.splice(1,0,'a','b','c')//[1,"a","b","c",2,3]
//返回值
arr.splice(1,2)//返回的是删除的元素组成的数组
/*
	splice(start[,num,itm1,itm2])
		-start:删除的起始位置,
			  如果start大于length，就是不删除
			  如果start过小是负数-2，从右到左查找 length +(start);如果负数的绝对值超过了length。起始位置被设定了length
		-num:可选，不写默认删除当前数组的末尾,表示删除的个数,如果小于0，或者是NAN，不删除任何一个元素
		-item1,item2...从删除的位置，添加第二个参数以后的内容
*/	
```

# 数组排序

## sort

```javascript
var arr = ['b','z','l','a'];
arr.sort();//['a','b','l','z'];
var num = [6,50,12,40];
num.sort(function(a,b){
    console.log(a,b);
    return(a-b)// 从小到大
})
//特殊排序
var arr = ["A","B","a","b"];
arr.sort(function(){
    var a = a.toLowerCase();
    var b = b.toLowerCase();
    if(a>b){
        return 1;
    }
    if(a<b){
        return -1
    }
    return 0;
})
console.log(arr);
//随机排序
var arr = ["a","b","c","d"]
arr.sort(function(a,b){
  return  Math.random() - 0.5 //0-1,不包含1 ->-0.5-0.5
})

/*
	sort
		-如果不提供任何的参数，则根据默认规则来进行排序，根据unicode来进行排序
		-如果提供参数，可以指定规则:
			-a
			-b
			a和b代表两个在比较的值
			如果a-b的结果:
				大于0：b排到a前面
				小于0：a拍到b前面
				等于0：不变
*/
```

## concat

```javascript
var arr1 = ["kai"]
var arr2 = ["ke"]
var arr3 = ["ba"]
arr1.concat(arr2,arr3)["kai","ke","ba"]//不会改变原数组 用来拼接数组并返回一个新数组
```

## join

```javascript
var arr1 = ["kai","ke","ba"]
arr1.join("");//kai,ke,ba 默认以逗号进行间隔
/*
	join
		把数组拼接出来，以字符串的方式，进行返回，如果不给参数，默认以逗号进行间隔
*/

```

## reverse

```javascript
var arr = ["a","b","c"]
arr.reverse()//["c","b","a"]  会改变原有的数组
arr//["c","b","a"]
```

## indexOf

```javascript
var arr =["a","b","c","a"];
arr.indexOf("a");//0 
arr.indexOf("a",1)//3
/*
	indexOf(searchValue[,fromIndex])
		在查找目标字符串中是否包含searchValue，如果包含返回第一次出现的索引值，如果不包含返回-1
		-searchValue:要查找的值
		-fromIndex:起始位置，默认为0,如果超出length或者等于，返回-1.
								如果是一个负数，小于length的负数，根据倒数来确认查找的位置 length +fromIndex
								超过length，则fromIndex为0;
*/
```

## lastIndexOf

```javascript
var arr =["a","b","c","a"];
arr.lastIndexOf("a");//3
arr.lastIndexOf("a",arr.length-2);//3
/*
从后往前进行搜索
*/
```

## slice

```javascript
var arr = ["a","b","c","d","e"]
arr.slice(2)//["d","e"] 不改变原数组
/*
	slice(begin,end)
		用于截取数组中的内容，返回一个新数组
			-begin
				-截取的起始位置
				-如果值超过了length，就会返回一个空数组给你
				-如果是负数，就是从倒数第begin个截取 length + begin
			-end
				-如果不给，默认到数组结尾
			深拷贝：
				-数据拷贝过来后，和原数组指尖完全没有任何关系了
			浅拷贝
				-数据拷贝过来后，里面的第一层的基本数据是没有关联了，但是里面的复杂类型，依旧是有关联
			赋值
				-数据不管是基本类型，还是复杂类型，都和原来的相关联的

*/
```

# 数组的新增方法

## forEach

```javascript
var arr = ['a','c','vv',1];
arr.forEach(callback[,thisArg]);
/*
	arr.forEach(callback) 对数组中的每一个元素，执行一次提供的函数
		-callback(ele,index,arr)
			-ele：循环过程中的每一位元素
			-index：当前循环的元素对应的下标值
			-arr：调用forEach的当前数组
		-thisArg:用于控制callback中的this指向
		该方法返回值是undefined；
*/
```

## filter

```javascript
var arr = [10, 20, 30, 40, 50, 60];
var newArr = arr.filter(function(ele, index, arr) {
    // console.log(this)
    // console.log(ele, index, arr)
    return ele >= 50;
}, arr)
console.log(newArr);

```

## map

```javascript
var arr = [10, 20, 30, 40, 50, 60, 70];
var newArr = arr.map(function(ele, index, arr) {
    return ele * 2;
}, arr)
console.log(newArr);//[20,40,60...]

/*
	map
		由数组中的每一位元素执行函数后的结果，作为新数组的值
*/
```

## reduce

```javascript
var arr = [10, 20, 30, 40, 50, 60, 70];
var num = 0;
var num2 = arr.reduce(function(result, ele, index) {
    console.log(result, ele, index)
    return result + ele;
}, 0);

/*0 10 0
10 20 1
30 30 2
60 40 3
100 50 4
150 60 5
210 70 6
280
*/

/*
	arr.reduce(callback,[,initvalue])
		对数组中的每一个元素执行callback函数，将结果根据callback函数中的条件，返回单个值
		-callback:执行的函数
			-result:结果
			-ele:当前正在循环的元素
			-index:索引值
		-initValue 对于result进行初始化
*/
```

## some和every

```javascript
var btn = document.querySelector('button');
    var checkboxs = document.querySelectorAll('ul input')
    var allcheck = document.querySelector('.all')
        //some 只能操作数组
    var checkBox = []
    for (var i = 0; i < checkboxs.length; i++) {
        checkBox.push(checkboxs[i]);
    }
    checkboxs.forEach(function(item) {
        item.onclick = function() {
            var a = checkBox.some(function(ele) {
                console.log(ele);
                return ele.checked;
            })
            btn.disabled = a ? false : true;
            //全选
            var b = checkBox.every(function(ele) {
                return ele.checked;
            })
            allcheck.checked = b ? true : false;
        }
    })
    btn.addEventListener('click', function() {
        alert("支付成功")
    })


/*
	some(callback)只可以在数组中使用
		测试数组中是否至少有一个元素通过了制定函数的测试，结果返回布尔值
		-callback 用于测试的函数
			-ele
			-index
			-array
		-thisAry
		
	every所有元素通过才通过
*/
```

# 对象

## 语法

```javascript
var obj = {
    name = "Reci",
    age:18
};
obj.name

for(var k in obj){
    console.log(k)//name age
    console.log(obj[k])// "Reci",18
}

Object.keys(obj)//["name","age"]
Object.valus(obj)//["Reci",18]
/*
	键值对key:value
*/
```

## 删除对象的值

```javascript
var obj = {
    name = "Reci",
    age:18
};
delete obj.name;
/*
	delete obj.key 通过这样的方式可以删除整个键值对
*/
```

# Json

```javascript
//var _json ='{"key":value}';
var _json = '{"name":"likun"}';
var _json2 = '[1,2,3]'
var a = JSON.parse(_json);
    console.log(a);//把json字符串转换为对象或者是数组

var obj = {
    name: 'reci'
}
var a = JSON.stringify(obj)//把对象转换为json字符串
    
    
/*
	JSON对象为了方便操作JSON的数据，所以JS中才专门准备了这样一个对象
	josn特点：
		key必须加引号
		json最后一个值后面不能跟逗号
*/

```

# math方法

## ceil(x)

```javascript
/*math只是一个对象*/
var num =1.1;
Math.ceil(num)//2
/*
	向上取整
*/
```

## floor

```javascript
var num = 1.1
Math.floor(num)//1
/*
	向下取整
*/
```

## round

```javascript
var num = 1.5;
Math.round(num)//2
/*
	四舍五入
*/
```

## 随机数random

```javascript
/*
	得到一个0-1之间的值，包含0不包含1
*/

function getNum(min, max) {
        return Math.round((Math.random()) * (max - min) + min);
    }
    var a = getNum(2, 7)
    console.log(a);//2-7之间的整数
```

## max.min.abs

```javascript
num = Math.max(num,0)//最小是0
num= Math.min(num,10)//最大是10

/*
	找一组数据中的最大值和最小值绝对值
*/
```

# ES6

## 变量声明

```javascript
var:
	1.可以重复声明
    2.无块级作用域
    3.不会进行预解析
let:
	1.不可以重复声明
    2.作用域：
    	全局作用域
        块级作用域
     3.不会进行预解析
const:
	1.常量（声明后不允许修改）
```



## 解构赋值

```javascript
//对象
let obj = {
    a:1,
    b:2
};
let {a,b} = obj;  //let a = obj.a; let b=obj.b
console.log(a,b)//1 2
//数组
let arr = ["a","b","c"]
let [e,f] =arr;
console.log(e,f)//a,b
//字符串
let a = 0;
let b =1;
[a,b] = [b,a] //快速交换ab的值

```





## 展开运算符

```javascript
let arr = [1,2,3,4];
let arr2 = ["a","b",...arr,"c","d"];//["a","b",1,2,3,4","c","d"]

//剩余参数
let [a,b,...c] = arr;
console.log(a,b,c)//1,2 [3,4]

//对象
let obj = {
    a:1,
    b:2
};
let obj2 = {
    ...obj,
    c:3,
    d:4
}
console.log(obj2)//{a:1,b:2,c:3,d:4}

```

## SET

```javascript
 //构造函数 
    let arr = [1, 2, 3, 3, 4, 5]
    let s = new Set(arr)//去重
    console.log(arr)//[1,2,3,3,4,5]
    arr = [...s];//重新赋值给arr
    console.log(arr);//[1,2,3,4,5]
    console.log(s);
/*
	s.size :数值的个数 相当于length
	s.clear:清空所有值
	s.delete(val):删除4
		参数val:要删除的值
		返回值：true，false
	s.add(6).add(7).add(8);
		val:添加一项
		返回：set本身
	s.has(3)//是否包含 返回布尔值
*/
```



## Map

```javascript
let arr = [
    ["a",1],
    ["b",2],
    ["c",3]
];
let m = new Map(arr);
console.log(m	)

/*
	m.clear()//清空所有制
	m.delete(key)//删除某一项
		参数：
			key:数据的key值
		返回值：
			true ||false
	m.get(b)//2
	m.has()
	m.set(key,val)
		参数：数据的key
		value:数据的value
		返回值：
			对象本身
*/
```



## 箭头函数

```javascript
let fn = (...arg)=>{
    console.log(1);
    console.log(arg);//剩余参数
}
fn();

let fn = nub =>nub *2;
console.log(fn(10));

let fn = ()=>"返回值";
console.log(fn())//返回值


/*
	箭头函数：
	(形参)=>返回值
	箭头函数没有arguments
	
	本身没有this，调用箭头函数this时指向的是其声明时所在的作用域的this；
*/
```



## 数组新增

### from

```javascript
Array.from(lis) //把一个类数组转换成真正的数组  常见的类数组有函数的参数arguments,DOM对象列表（比如通过document.querySelectorAll 得到的列表），jQuery对象(比如$("div"))
	//类数组:有下标 有length 无方法 是Object类型
```

### of

```javascript
Array.of(1,2,3,4,"A");//[1,2,3,4,"A"]  类数组
```

### isArray()

```javascript
Array.isArray(lis)//判断是否是一个数组
lis = [...lis]
```

### find

```java
let arr = [1,2,3,4]
let val = arr.find((item,index)=>{
    if(item>3){
        return true
    }
}
val = arr.find(item=>item>=3);//3
    console.log(val)
    
 /*
 	查找数组中满足条件的第一个值
 	返回满足条件的值，没有的话返回undefined
 */
```

### findIndex

```javascript
let arr = [1,2,3,4]
let index = arr.findIndex(item=>item>=3);
console.log(index);//2
```

### flat数组扁平化把数组变为一维数组

```javascript
   let arr = [
        ["a", 1],
        ["b", 2],
        ["c", 3],
       [
           
       ]
    ];
    console.log(arr);
    console.log(arr.flat(Infinity));//["a",1,"b",2,"c",3]
]
```

### fill

```javascript
let arr = [1, 2, 3, 4]
var arr1 = arr.fill("a");
var arr2 = arr.fill("a",4);
console.log(arr1)//["a","a","a","a"]
console.log(arr2)//[1,2,3,"a"]  改变原数组
/*
	fill(填充的元素，填充的起始位置，填充的结束位置不包括)
*/
```

### includes

```javascript
let arr = ["a", "b", "c", "d", "e"]

var arr1 = arr.includes("c", 3);
console.log(arr1);

/*
	includes(valueToFind,[,fromIndex])
		-valueToFind 需要查找的值
		-fromIndex 查找的起始位置
*/
```

## 字符串新增

### includes

### startWith和endsWith

```javascript
let str = 'kaikeba和妙味课堂是一家培训机构'
console.log(str.startsWith("妙味课堂", 8));
console.log(str.endsWith("培训机构"));
```

### repeat

```javascript
let str = "a";
console.log(str.repeat(30));//30个a
```

### 模板字符串

```javascript
let p = document.querySelector('p')
let name = "小明"
let age = 18
let school = "初中"
p.innerHTML = `今年<strong>${name}</strong>就要<strong>${age>13?"保密":age}<strong>岁了，终于升入了<strong>${school}</strong>了`
//${}插值表达式
/*
	模板字符串本身可以换行
	
*/

```



## 对象新增

### 简洁写法

```javascript
let a = 0;
let b = 1;
let name = "aaa";
let obj = {
    a,
    b,
    c(){
        console.log("A")
    },
    [name]:111
}
consoloe.log(obj)//{a:0,b:1,c:f}
```

### 合并

```javascript
let obj = {
    a: 1,
    b: 2
};
let obj2 = {
    c: 3,
    d: 4
};
Object.assign(obj, obj2);
console.log(obj);
```

### 比较

```javascript
Object.is(1,"1");//true
```

## babel

babel进行编译浏览器的兼容问题。

## ES6高阶

同步阻塞：A调用B，B处理获得结果，才返回给A，A在这个过程中，一直等待B的处理结果，没有拿到结果之前，需要A(调用者)一直等待和确认调用结果是否返回，拿到结果，然后继续往下执行。

做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了，再去做下面的事

异步非阻塞：A调用B，无需等待B的结果，B通过状态，通知等来通知A或回调函数来处理。

做一件事，不用等待事情的结果，然后就去忙别的了，有了结果，在通过状态来告诉我们，或者通过回调函数来处理

### promise

```javascript
   let p1 = new Promise((resolve,reject)=>{
        // resolve(123)
        reject('err')
   })
   //一、 pending resolved rejected
```

### then()

```javascript
    let p1 = new Promise((resolve,reject)=>{
        // resolve("成功")
        reject("失败")
    }).then(res=>{
        console.log(res);
    },err=>{
        console.log(err);
    })
         //三、then()的三种返回值 有返还 无返还 返还promise 最终得到promise对象 链式操作
  let p1 = new Promise((resolve,reject)=>{
        resolve("成功")
        // reject("失败")
    }).then(res=>{
        // return 111;
        return new Promise(resolve=>resolve("返回的值"))
    }).then(res=>{
        console.log(res);
    }).catch(err=>{
        console.log(err);
    })
    console.log(p1);
```

### promise静态方法 all

```javascript
let p1 = new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve("1")
        })
    })
let p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve("222")
    })
})
//必须所有promise都要resolve才能拿到结果
Promise.all([p1,p2]).then(res=>{
    console.log(res);
})
```

### race

```javascript
let p1 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve("1")
    },3000)
})
let p2 = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve("222")
    },2000)
})
//谁执行的快执行谁
Promise.race([p1,p2]).then(res=>{
    console.log(res);
})
```

### finally

```javascript
//不管成功还是失败都会执行finally
p1.then(res=>{
    console.log(res)
}).finally(()=>{
    console.log("执行了")
})
```

## async-await

await 表达式的运算结果取决于它等的东西。

如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。

如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。	

```javascript
 function test(x){
            return new Promise((resolve)=>{
                setTimeout(()=>{
                    resolve(x)
                },3000)
            })
        }
        async function myAsync(){
            let res1 = await test('helloword1');
            console.log(res1);
            console.log(("helloword2"));
        }
        myAsync()
        console.log("helloword3");

//输出结果 直接输出helloword3 3秒钟之后同时输出helloword1 helloword2
```



# 移动端适配

## viewport相关配置

| 属性          | 值                    | 描述                              |
| ------------- | --------------------- | --------------------------------- |
| width         | 正整数或device-width  | 以像素为单位，定义布视口的宽度    |
| height        | 正整数或device-height | 以像素为单位，定义布局视口的宽度  |
| initial-scale | 允许是小数            | 定义页面初始缩放比例              |
| minimum-scale | 0.0-10.0              | 定义缩放的最小值                  |
| maximum-scale | 允许是小数            | 定义缩放的最大值（ios10以上无效） |
| user-scalable | yes/no                | 设置是否允许缩放，同上无效        |

```javascript
<meta name ="viewport" content = "width=device-width",initial-scale =1,minimum-scale=1,maximum-scale=1>

```

注意事项：

1.ios10及+设置最大缩放无效

2.initial和width是有冲突的

3.initial和最小值是一致的

4.部分安卓机型是不接受 width=具体数值这样的操作

## rem适配root em

### rem会根据html的font-size去计算

```html
<style>
    div{
        width:10rem;
        height:10rem;
    }
</style>
<script>
	var html = document.documentElement;
    var widths = html.clientWidth;
    var num =10;
    var s = widths / 10
    html.style.fontSize = s +'px';
    
</script>

```

### vw vh

根据视口屏幕来计算 用于移动端

vw水平方向：类似于百分比 100vw  相当于屏幕的百分之100  百分比会受到父级的影响 

vh垂直方向：

vmin vmax :选取vw和vh中较小或者较大的地方

```javascript
<style>
	html{
        font-size:10vw;
    }
	div{
        width:5rem;
        height:5rem;
        background:pink;
    }
    
</style>
```



## apache

### 调试步骤

1.连接apache 把要测试的网页放到htdocs中，输入本机IP地址加端口号访问，打开网页复制网址发送给手机

2.如果想要看页面结构下载vconsole

```javascript
<script src="./js/1.js"></script> // https://cdn.bootcdn.net/ajax/libs/vConsole/3.3.4/vconsole.min.js
    <script>
        // 初始化
        var vConsole = new VConsole();
        console.log('Hello world11');
    </script>
```

## 横竖屏适配

```javascript
@media screen and(orientation:portrait){//竖屏
    div{
        background:red;
    }
}
@media screen and(orientation:landscape){//横屏
    div{
        background:red;
    }
}
```

## iphoneX适配

```javascript
<meta name ="viewport" content = "viewport-fit=cover">//利用iphonex专属样式viewport-fit对网页设置安全区   
    <style>
    body {
        padding-bottom: constant(safe-area-inset-bottom);
        padding-bottom: env(safe-area-inset-bottom);
    }
</style>//constant:小于ios11.2版本生效，env:大于ios11.2版本生效
```

+ safe-area-inset-left/right/top/bottom

## 1px适配方案

```javascript
div{
    height:200px;
    position:relative;
}
.border_1px:before{
    content:'';
    position:absolute;
    top:0;
    height:1px;
    width:100%;
    background-color:#000;
    transform-origin:0% 0%;//左上角缩放上边框  右下角缩放下边框
}
@media only screen and (-webkit-min-device-pixel-ratio:2){
    .border_1px:before{
        transform:scale(0.5)
    }
}
@media only screen and (-webkit-min-device-pixel-ratio:3){
    .border_1px:before{
        transform:scale(0.33)
    }
}
<div class="border_1px">
```

## 图片模糊问题

```javascript
.avatar{
    background-image:url(1.png)
}
@media only screen and (-webkit-min-device-pixel-ratio:2){
    .avatar{
        background-image:url(2.png)
    }
}
@media only screen and (-webkit-min-device-pixel-ratio:3){
    .avatar{
        background-image:url(3.png)
    }
}
```

## 滚动穿透

```javascript
 #alerta {
        position: fixed;
        width: 100vw;
        height: 100vw;
        background: rgba(0, 0, 0, .5);
        left: 0;
        top: 0;
        display: none;
    }
    
    #text {
        background-color: yellow;
        color: #fff;
        /* position: fixed; */
    }
    <script>
        var btn = document.querySelector('.btn')
        var alerta = document.querySelector('#alerta')
        var txt = document.querySelector('#text')
        btn.onclick = function() {
            alerta.style.display = 'block';
            txt.style.position = 'fixed';
            // txt.style.position = 'static'
        }
    </script>
```

## 键盘唤起

```javascript
main{
    padding:2rem 0;
    position:absolute;
    top:60px;
    bottom:60px;
    overflow-y:scroll;
    width:100%;
    -webkit-overflow-scrolling:touch;//滚动顺滑
}
```

当底部根据页面进行fixed定位的时候，键盘弹出一瞬间，fixed会失效，变成类似absoulte 

### 常用iphone meta标签

```javascript
<meta name="apple-mobile-web-app-capable" content="yes"/>//删除默认的苹果工具栏和菜单栏，默认为no
<meta name="apple-touch-fullscreen" content="yes"/>//全屏显示
<link href="short_cut_114*114.png" rel="apple-touch-icon-precomposed">//图标
<meta name="format-detection" content = "telephone=no,email=no"/>//禁止自动识别为电话号码和邮件
<a href="tel:123123">123123</a>//手动开启拨打电话功能
<a href="sms:123123">123123</a> // 可以跳去短信页面，给该手机号发送信息
<a href="mailto:895146260@qq.com">发送邮件</a>
<meta name="format-detection" content="email=no"/>
 
```

## 移动端默认样式

+ 移动端默认字体
  + 数字和英文字体可使用Helveticca字体，IOS和Android都有这个字体
  + 手机系统都有自己默认的字体，直接使用默认的

```javascript
body{
    font-family:Helvetica
}
```



+ 字体大小

  如果只是适配手机，可以使用px

  IOS系统中，链接、按钮等点击会有灰色遮罩

  ```javascript
  a,button,input,textarea{-webkit-tap-highlight-color:rgba(0,0,0,0)}//去掉灰色遮罩
  
  button,input{
      -webkit-appearance:none;
      border-radius:0;
  }//去除圆角
  
  html{
      -webkit-text-size-adjust:100%
  }//禁止文本缩放
  ```

  

# git

## git status

## git add 添加要管理的文件

+ git add . 添加所有文件到暂存区

## git config --global user.email "895146260@qq.com"

## git config -- global user.name "kk"

## git config --global -l 查看4.5

## git commit  进入模式

+ 新建一个a.txt（touch a.txt）

+ （1）在插入编辑模式下编辑文件。

  （2）按下 “ESC” 键，退出编辑模式，切换到命令模式。

  （3）在命令模式下键入"ZZ"或者":wq"保存修改并且退出 。

  （4）如果只想保存文件，则键入":w"，回车后底行会提示写入操作结果，并保持停留在命令模式。

git commit -m ‘更改了b的内容’

git commit -a -m '描述'

git commit --amend -m 覆盖提交

touch a.txt 新建文件

mkdir first 新建文件夹

## git log查看已经提交的

三个工作区域

+ 工作目录  已修改
+ 暂存区域 已暂存
+ git仓库 已提交

工作目录中修改或创建文件  -》暂存文件 -》找到暂存区文件，提交更新

+ untracked ：未被追踪的文件
+ stage : 暂存 我们通过add添加的文件，进入了准备区域等待被提交，这样的区域我们称为"暂存区"
+ git reflog 打印详细的信息

## 删除

+ git rm c.txt 既删除仓库中 又删除工作目录中
+ git rm --cache 只删除仓库中 不删除工作目录中
+ git rm -f 强制删除

## 移动文件

+ git mv a.txt first/a.txt 重命名操作
  + 相当于：
  + mv d.txt dd.txt
  + git rm d.txt
  + git add dd.txt

## 查看命令

### git status -s 

+ ??未追踪文件
+ A添加到暂存区的
+  M被修改但是未添加至暂存区
+ M被修改但是放到暂存区了
+ MM修改后放入暂存区，并且又再次修改

### git diff 查看工作目录的操作 

+ git diff --staged 暂存区和commit区域差异的命令

### git log

+ ​	git log --pretty

  + oneline 哈希和描述
  + short 哈希作者和描述
  + full哈希 作者 提交者 描述
  + fuller 哈希 作者 日期 提交者 提交日期 描述
  + format 定制要显示的记录格式

  此处的作者：实际修改的人

  提交者：最后将此工作成果提交到仓库的人

  git log --decorate --oneline

  git log --decorate --oneline --all --graph   

## 提交对象

Git保存的并不是文件的变化或者差异，而是一系列的不同时刻的文件快照

提交操作时Git会保存一个提交对象，该对象中包含一个指向暂存内容快照的指针，作者姓名，邮箱，父对象指针以及提交输入信息

+ 首次提交的对象没有父对象
+ 普通的提交有一个父对象
+ 多个分支合并的有多个父对象

​	master分支：

​	Git的分支本质上仅仅是指向提交对象的可变指针。

​	Git默认分支名：master，它会在每一次提交中自动前移。

**Git的分支master并不是一个特殊分支，它和其他的分支完全没有区别，之所以每个分支都是master是git ini命令默认创建，而大部分人又懒得去改

## 创建分支 git branch 查看分支

1.创建分支：git branch 分支名称

​	创建出来的分支，并不会改变我们当前所在的位置

2.切换分支：git checkout 分支名

​	将Head指向切换的分支

将工作目录恢复成当前分支的快照

简写命令：git checkout -b branch1 创建之后直接指向此分支

3.合并分支:git merge branch1 将branch1合并到master

![image-20200804121641735](C:\Users\kk\AppData\Roaming\Typora\typora-user-images\image-20200804121641735.png)

4.快速前移 ：

git merge --no--ff -m "这是一次合并操作" branch1

​	--no-ff 禁止快速前移（）

## 分支冲突：

​	如何判断是否会引起分支冲突：

​	master和branch1处于同一条commit路径上(直接级祖先关系)

​	master和branch1直接进行合并，不会引起冲突

​		1，分析master和branch1中的修改是否一致，如果一致合并将会成为一次空合并(因为内容完全一致，没有合并的需要)

​		2,如果不一致，是否修改的同一个文件内容，如果是，产生冲突

解决冲突：

​	1.手动解决冲突部分

​	2.解决完成后再次提交，会以这次提交内容为准

删除分支：

​	合并完成后，分支就没有任何额后期用途了，这时候我们需要手动删除分支，以防止自己词穷的时候出现重复命名分支的情况

​		git branch -d 分支名称

如果你的分支，从未合并：git branch -D 分支名称

​			head所指向的分支，无法删除

取消合并：

​	git merge --abort

## 撤销大集合

git rm --cached a.txt 库中删除，工作目录中保存

git checkout -- a.txt 撤销还没有加入暂存区的修改

git reset HEAD a.txt 撤销添加到暂存区的文件

git commit -m "新建一个b文件" --amend

git reset HEAD^^

git reset --hard e3608e9回退版本

fit  reset HEAD . 撤销所有暂存区里面的文件

## git diff 可以查看工作区和暂存区的区别

## git diff  "版本号1" "版本号2"查看两个版本的区别

# node

dependencies:运行依赖

devDependencies:开发依赖 less sass

## fs文件操作 所有文件操作没有加async 那么都是异步操作 否则是同步

### 写文件

```java
fs.writeFile("1.txt", "我是写入的文字1111", {flag:"w"},function(err) {
    if (err) {
        return console.log(err);;
    }
    console.log("写入成功");
})
    a:追加写入
    w：写入覆盖
    r:读取
```

### 读取文件

```javascript
fs.readFile("1.txt", "utf-8", (err, data) => {
    if (err) {
        return console.log(err)
    }
    console.log(data)
})

let data = fs.readFileSync("1.txt");//同步拿到返还值
console.log(data.toString());
```

### 修改名称

```javascript
fs.rename("2.txt", "3.txt", err => {
    if (err) {
        return console.log(err);
    }
    console.log("修改成功")
})
```

### 删除

```javascript
fs.unlink("3.txt", (err) => {
    if (err) {
        return console.log(err)
    }
    console.log("删除成功")
})
```

### 复制

```javascript
fs.copyFile("1.txt", "2.txt", err => {
    if (err) {
        return console.log(err)
    }
    console.log("复制成功")
})
```



## 目录操作

### 创建目录

```javascript
//创建
fs.mkdir("11", err => {
        if (err) {
            return console.log(err)
        }
        console.log("创建成功")
    })
```

### 修改目录名称

```javascript
    //修改目录名称
fs.rename("11", "22", err => {
    if (err) {
        return console.log(err)
    }
    console.log("修改成功")
})
```

### 读取目录

```javascript
fs.readdir("22", (err, data) => {
    if (err) {
        return console.log(err)
    }
    console.log(data)
})
```

### 删除目录

```javascript
//删除目录（只能空文件夹/目录）
fs.rmdir("11", err => {
    if (err) {
        return console.log(err)
    }
    console.log("删除成功")
})
//删除非空文件夹
//先删除目录中的文件 --》删除空目录
function removeDir(path) {
    let data = fs.readdirSync(path)
    data.forEach(item => {
        //是文件或者是目录 如果是文件直接删除，否则是目录就递归
        let url = path + "/" + item;
        let stat = fs.statSync(url);
        if (stat.isDirectory()) {
            //目录
            removeDir(url);
        } else {
            fs.unlinkSync(url)
        }
    })
    fs.rmdirSync(path);
}
```

### 判断文件和目录是否存在

```javascript
//判断文件和目录是否存在
fs.exists("1.txt", exists => {
    console.log(exists)
})
```

### 获取文件或者目录的详细信息系

```javascript
fs.stat("index.js", (err, stat) => {
    if (err) {
        return console.log(err)
    }
    // console.log(stat)
    //判断是否是一个文件
    let res = stat.isFile();
    console.log(res);
    //判断是否是一个文件夹
    let res2 = stat.isDirectory()
    console.log(res2)
})
```

## buffer

### 创建buffer

```javascript
//buffer创建
// new Buffer()
let buffer = Buffer.alloc(65*1024);
console.log(buffer);	

let buffer = Buffer.from("大家好")
console.log(buffer);

let buffer = Buffer.from([0xe5, 0xa4, 0xa7, 0xe5, 0xae, 0xb6, 0xe5, 0xa5, 0xbd])
console.log(buffer.toString());//大家好
```

## 解决拼接乱码问题

```javascript
let buffer1 = Buffer.from([0xe5, 0xa4, 0xa7, 0xe5])
let buffer2 = Buffer.from([0xae, 0xb6, 0xe5, 0xa5, 0xbd])
    // console.log(buffer1.toString());
let newBuffer = Buffer.concat([buffer1, buffer2])
console.log(newBuffer.toString());//大家好

let { StringDecoder } = require("string_decoder");
let decoder = new StringDecoder();
let res1 = decoder.write(buffer1);
let res2 = decoder.write(buffer2);
console.log(res1 + res2);//大家好 性能要好一些
```

## stream流

```javascript
//正常读取
const fs = require("fs");
// let res = fs.readFileSync("1.txt");
// console.log(res.toString());
//流读取	 64kb 一个节点 
let res = fs.createReadStream("65kb")
res.on("data", chunk => {
    console.log(chunk.toString());
})
//创建一个65kb的文件：
// let buffer = Buffer.alloc(65 * 1024)
// fs.writeFile("65kb", buffer, err => {
//     if (err) {
//         return console.log(err)
//     }
//     console.log("写入成功");
// })


let rs = fs.createReadStream("1.txt")
let ws = fs.createWriteStream("2.txt");
rs.pipe(ws);
```

# 模板引擎

## Pug 

### Pug index.js

```javascript
//index.js
const Koa = require("koa");
const Router = require("koa-router");
const views = require("koa-views");
let app = new Koa();
let router = new Router();
app.use(views(__dirname + "/views", {
    map: {
        html: 'pug'
    }
}));
router.get("/", async ctx => {
    // ctx.body = "hello";
    let users = [{ name: "张三", age: 20, height: "178cm" }, { name: "张三2", age: 20, height: "178cm" }, { name: "张三3", age: 20, height: "178cm" }]
    await ctx.render("index.pug", {
        data: "我是数据",
        users
    });
})
app.use(router.routes());
app.listen(3000);
```

### index.pug

```java
<!DOCTYPE html>
html(lang="en")
    head
        meta(charset="UTF-8")
        meta(name="viewport", content="width=device-width, initial-scale=1.0")
        title Document
        style.
            .mydiv{
                width:200px;
                height:w00px;
                background:red;
            }
    body
        h1 我是标题
        div 我是div
        div(class="mydiv") 我是类名为mydiv的div
            span 我是span
        .mydiv2(style={width:"100px",height:"100px",background:"blue"}) 我是div2
        #myid  我是id
        //-我是pug注释
        //-
            我是第一行
            我是第二行
        // 我是html注释
        //
            我是第一行
            我是第二行
        div
            | hello 
        - let str = "你好"
        p #{str}
        p #{data}
        ul
            each item,index in users
                li 姓名是: #{item.name};年龄是:#{item.age};身高是:#{item.height};索引是:#{index}
        - for(let i =0;i<4;i++)
            span 我是循环出来的数据#{i}
        - let num =33
            case num
                when 1
                    p num 是1
                when 2
                    p num 是2
                default
                    p num 是其他值

        mixin mydiv
            div 我是非常常用的div
        
        +mydiv
        +mydiv
        mixin pet(name,sex)
            p 这是一只#{name};它的性别是#{sex}
        +pet("狗狗","公的")
        +pet("猫猫","目的")
        //公共模板
        include common.pug

        script(type="text/javascript").
            console.log(1111)
```

## numjucks

### index.js

```javascript
const Koa = require('koa');
const Router = require("koa-router");
const nunjucks = require("koa-nunjucks-2");

let app = new Koa();
let router = new Router();
app.use(nunjucks({
    ext: "html", //.njk
    path: __dirname + "/views",
    nunjucksConfig: {
        trimBlocks: true //防止Xss漏洞
    }
}))
router.get("/", async ctx => {
    // ctx.body = "hello";
    await ctx.render("index", {
        username: '张三',
        num: 4,
        array: [{
            name: '张三',
            age: "20"
        }, {
            name: '李四',
            age: "18"
        }]
    })
})
app.use(router.routes())
app.listen(8000)
```

# 	本地存储

## cookie

```javascript
// document.cookie = "test=test;Max-Age=3600";
//设置cookie方法
function setCookie(name, value, options = {}) {
    let cookieData = `${name}=${value};`;
    for (let key in options) {
        let str = `${key}=${options[key]};`;
        cookieData += str;
    }
    document.cookie = cookieData;
}
//获取cookie方法
function getCookie(name) {
    let arr = document.cookie.split("; ");	
    for (let i = 0; i < arr.length; i++) {
        let arr2 = arr[i].split("=");
        if (arr2[0] === name) {
            return arr2[1]
        }
    }
    return "";
}
```

## localStorage

```javascript
设置localStorage.setItem
localStorage.setItem("test3", "测试文字")
localStorage.setItem("test32", "测试文字2")
读取
let local = localStorage.getItem("test3")
删除指定的localstorage
localStorage.removeItem("test3");
清除所有localstorage
localStorage.clear();

```

# status常用状态码

| http状态码 | 描述                                                   |
| ---------- | ------------------------------------------------------ |
| 100        | 继续，继续响应剩余部分，进行提交请求                   |
| 200        | 成功                                                   |
| 301        | 永久移动，请求资源永久移动到新位置                     |
| 302        | 临时移动，请求资源临时移动到新位置                     |
| 304        | 未修改，请求资源对比上次未被修改，响应中不包含资源内容 |
| 401        | 未授权，需要身份验证                                   |
| 403        | 禁止，请求被拒绝                                       |
| 404        | 未找到，服务器未找到需要资源                           |
| 500        | 服务器内部错误，服务器遇到错误，无法完成请求           |
| 503        | 服务器不可用，临时服务器过载，无法处理请求             |

# socket.io

![image-20200819121436899](C:\Users\kk\AppData\Roaming\Typora\typora-user-images\image-20200819121436899.png)